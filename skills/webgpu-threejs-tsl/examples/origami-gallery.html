<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Origami Gallery - 12+ 3D Motion Graphics</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #0a0a0a;
      color: #e0e0e0;
      overflow: hidden;
    }

    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #controls {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 24px;
      max-width: 400px;
      backdrop-filter: blur(20px);
    }

    h2 {
      font-size: 20px;
      margin-bottom: 20px;
      color: #fff;
      font-weight: 600;
      letter-spacing: -0.5px;
    }

    .control-group {
      margin-bottom: 24px;
    }

    .control-group:last-child {
      margin-bottom: 0;
    }

    .control-group label {
      display: block;
      margin-bottom: 12px;
      font-size: 11px;
      color: #666;
      text-transform: uppercase;
      letter-spacing: 1px;
      font-weight: 600;
    }

    .origami-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .matcap-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 8px;
    }

    .btn {
      padding: 12px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      color: #999;
      border-radius: 8px;
      cursor: pointer;
      font-size: 11px;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      text-align: center;
      font-weight: 500;
    }

    .btn:hover {
      border-color: rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.05);
      color: #fff;
      transform: translateY(-1px);
    }

    .btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-color: transparent;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
    }

    #stats {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 8px;
      padding: 12px 16px;
      font-size: 11px;
      font-family: 'Monaco', 'Courier New', monospace;
      backdrop-filter: blur(20px);
    }

    #stats div {
      margin-bottom: 4px;
      color: #999;
    }

    #stats div:last-child {
      margin-bottom: 0;
    }

    #stats span {
      color: #667eea;
      font-weight: 600;
    }

    .info {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(10, 10, 10, 0.95);
      border: 1px solid rgba(255, 255, 255, 0.05);
      border-radius: 12px;
      padding: 20px;
      max-width: 300px;
      font-size: 12px;
      line-height: 1.8;
      color: #999;
      backdrop-filter: blur(20px);
    }

    .info strong {
      color: #667eea;
      font-weight: 600;
    }

    .info .title {
      font-size: 14px;
      color: #fff;
      margin-bottom: 12px;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>

    <div id="controls">
      <h2>Origami Gallery</h2>

      <div class="control-group">
        <label>Geometric Composition</label>
        <div class="origami-grid">
          <button class="btn active" data-item="1">Torus Rings</button>
          <button class="btn" data-item="2">Circle Blades</button>
          <button class="btn" data-item="3">Rotating Discs</button>
          <button class="btn" data-item="4">Orbital Rings</button>
          <button class="btn" data-item="5">Cube Matrix</button>
          <button class="btn" data-item="6">Half Pipe</button>
          <button class="btn" data-item="7">Stack Flip</button>
          <button class="btn" data-item="8">See Saw</button>
          <button class="btn" data-item="9">Pulse Tower</button>
          <button class="btn" data-item="10">Quarter Circle</button>
          <button class="btn" data-item="11">Wave Spheres</button>
          <button class="btn" data-item="12">Arrow Spin</button>
        </div>
      </div>

      <div class="control-group">
        <label>Material Surface</label>
        <div class="matcap-grid">
          <button class="btn active" data-matcap="1">Glossy 1</button>
          <button class="btn" data-matcap="2">Glossy 2</button>
          <button class="btn" data-matcap="3">Glossy 3</button>
        </div>
      </div>
    </div>

    <div class="info">
      <div class="title">Original Origami Demo</div>
      <strong>12+ 3D Motion Graphics</strong><br>
      Created by deadrabbbbit<br><br>
      • GSAP Timeline Animations<br>
      • Matcap Materials<br>
      • WebGPU Renderer<br>
      • Three.js r171
    </div>

    <div id="stats">
      <div>FPS: <span id="fps">0</span></div>
      <div>Item: <span id="current-item">Torus Rings</span></div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.module.js",
      "three/tsl": "https://cdn.jsdelivr.net/npm/three@0.171.0/build/three.webgpu.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.171.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { WebGPURenderer } from 'three/tsl';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // State
    let scene, camera, renderer, controls;
    let currentGroup = null;
    let currentItem = 1;
    let currentMatcap = 1;
    let matcapTextures = {};
    let activeTimeline = null;

    // Stats
    let frameCount = 0;
    let lastTime = performance.now();

    // DOM
    const canvas = document.getElementById('canvas');
    const itemButtons = document.querySelectorAll('[data-item]');
    const matcapButtons = document.querySelectorAll('[data-matcap]');
    const fpsSpan = document.getElementById('fps');
    const currentItemSpan = document.getElementById('current-item');

    // Item names
    const itemNames = {
      1: 'Torus Rings',
      2: 'Circle Blades',
      3: 'Rotating Discs',
      4: 'Orbital Rings',
      5: 'Cube Matrix',
      6: 'Half Pipe',
      7: 'Stack Flip',
      8: 'See Saw',
      9: 'Pulse Tower',
      10: 'Quarter Circle',
      11: 'Wave Spheres',
      12: 'Arrow Spin'
    };

    // Initialize
    async function init() {
      try {
        // Setup Three.js scene
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);

        camera = new THREE.PerspectiveCamera(
          45,
          window.innerWidth / window.innerHeight,
          0.1,
          1000
        );
        camera.position.set(0, 0, 10);

        renderer = new WebGPURenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        await renderer.init();

        controls = new OrbitControls(camera, canvas);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 20;

        // Load matcap textures
        const textureLoader = new THREE.TextureLoader();
        matcapTextures[1] = await textureLoader.loadAsync('../public/matcaps/1.jpeg');
        matcapTextures[2] = await textureLoader.loadAsync('../public/matcaps/2.jpeg');
        matcapTextures[3] = await textureLoader.loadAsync('../public/matcaps/3.jpeg');

        // Create initial item
        createItem(currentItem);

        // Setup event listeners
        setupEventListeners();

        // Start render loop
        animate();

        console.log('✅ Origami Gallery initialized!');
      } catch (error) {
        console.error('Initialization failed:', error);
      }
    }

    // Create matcap material
    function createMatcapMaterial() {
      return new THREE.MeshMatcapMaterial({
        matcap: matcapTextures[currentMatcap]
      });
    }

    // Create origami items
    function createItem(itemNumber) {
      // Clean up existing
      if (currentGroup) {
        if (activeTimeline) {
          activeTimeline.kill();
          activeTimeline = null;
        }
        scene.remove(currentGroup);
        disposeGroup(currentGroup);
      }

      const group = new THREE.Group();

      switch (itemNumber) {
        case 1:
          createItem1(group);
          break;
        case 2:
          createItem2(group);
          break;
        case 3:
          createItem3(group);
          break;
        case 4:
          createItem4(group);
          break;
        case 5:
          createItem5(group);
          break;
        case 6:
          createItem6(group);
          break;
        case 7:
          createItem7(group);
          break;
        case 8:
          createItem8(group);
          break;
        case 9:
          createItem9(group);
          break;
        case 10:
          createItem10(group);
          break;
        case 11:
          createItem11(group);
          break;
        case 12:
          createItem12(group);
          break;
      }

      scene.add(group);
      currentGroup = group;
      currentItem = itemNumber;
      currentItemSpan.textContent = itemNames[itemNumber];
    }

    // ITEM 1: Concentric Torus Rings
    function createItem1(parent) {
      const meshes = [];
      for (let i = 0; i < 4; i++) {
        const geometry = new THREE.TorusGeometry((i + 1) * 0.5, 0.1, 16, 32);
        const material = createMatcapMaterial();
        const mesh = new THREE.Mesh(geometry, material);
        parent.add(mesh);
        meshes.push(mesh);
      }

      activeTimeline = gsap.timeline({ repeat: -1, repeatDelay: 0.5 });
      activeTimeline.to(meshes.map(m => m.rotation), {
        y: `+=${Math.PI * 2}`,
        x: `-=${Math.PI * 2}`,
        duration: 1.5,
        stagger: { each: 0.15 }
      });
    }

    // ITEM 2: Circle of Rotating Blades
    function createItem2(parent) {
      const radius = 3;
      const count = 20;
      const groupRef = new THREE.Group();
      groupRef.scale.setScalar(0.6);
      parent.add(groupRef);

      const meshes = [];
      for (let i = 0; i < count; i++) {
        const geometry = new THREE.BoxGeometry(1, 0.2, 1);
        const material = createMatcapMaterial();
        const mesh = new THREE.Mesh(geometry, material);

        const angle = (i / count) * 2 * Math.PI;
        const holder = new THREE.Group();
        holder.rotation.z = angle;
        holder.position.x = Math.cos(angle) * radius;
        holder.position.y = Math.sin(angle) * radius;
        holder.add(mesh);
        groupRef.add(holder);
        meshes.push(mesh);
      }

      activeTimeline = gsap.timeline();
      activeTimeline.to(meshes.map(m => m.rotation), {
        y: `+=${Math.PI * 2}`,
        repeat: -1,
        duration: 6,
        ease: 'none'
      });
      activeTimeline.to(groupRef.rotation, {
        z: Math.PI * 2,
        duration: 24,
        ease: 'none',
        repeat: -1
      }, 0);
    }

    // ITEM 3: Rotating Cylinder Discs
    function createItem3(parent) {
      const radius = 3;
      const count = 8;
      const groupRef = new THREE.Group();
      groupRef.scale.setScalar(0.6);
      parent.add(groupRef);

      for (let i = 0; i < count; i++) {
        const geometry = new THREE.CylinderGeometry(1, 1, 0.1, 64);
        const material = createMatcapMaterial();
        const mesh = new THREE.Mesh(geometry, material);

        const angle = (i * 2 * Math.PI) / count + Math.PI / 4;
        const holder = new THREE.Group();
        holder.position.x = radius * Math.cos(angle);
        holder.position.y = radius * Math.sin(angle);
        holder.rotation.z = (i * 2 * Math.PI) / count;
        holder.rotation.x = Math.PI / count;
        mesh.rotation.y = Math.PI / 2;
        holder.add(mesh);
        groupRef.add(holder);

        gsap.to(holder.rotation, {
          x: `+=${Math.PI * 2}`,
          y: `+=${Math.PI * 2}`,
          z: `+=${Math.PI * 2}`,
          duration: 5 + Math.random() * 2,
          repeat: -1,
          ease: 'none'
        });
      }

      gsap.to(groupRef.rotation, {
        z: `-=${Math.PI * 2}`,
        duration: 10,
        repeat: -1,
        ease: 'none'
      });
    }

    // ITEM 4: Orbital Rings with Cones
    function createItem4(parent) {
      const ring1 = new THREE.Mesh(
        new THREE.TorusGeometry(2.1, 0.1),
        createMatcapMaterial()
      );
      parent.add(ring1);

      const ring2 = new THREE.Mesh(
        new THREE.TorusGeometry(1.8, 0.1),
        createMatcapMaterial()
      );
      ring2.rotation.x = Math.PI / 2;
      parent.add(ring2);

      const cone1 = new THREE.Mesh(
        new THREE.ConeGeometry(0.8, 1.13, 4),
        createMatcapMaterial()
      );
      cone1.position.y = 0.8;
      cone1.scale.setScalar(0.8);
      parent.add(cone1);

      const cone2 = new THREE.Mesh(
        new THREE.ConeGeometry(0.8, 1.13, 4),
        createMatcapMaterial()
      );
      cone2.position.y = -0.8;
      cone2.rotation.x = -Math.PI;
      cone2.scale.setScalar(0.8);
      parent.add(cone2);

      activeTimeline = gsap.timeline({ repeat: -1 });
      activeTimeline.to(ring1.rotation, {
        z: `+=${Math.PI * 2}`,
        x: `+=${Math.PI * 2}`,
        duration: 4,
        ease: 'none'
      }, 0);
      activeTimeline.to(ring2.rotation, {
        z: `-=${Math.PI * 2}`,
        x: `-=${Math.PI * 2}`,
        duration: 4,
        ease: 'none'
      }, 0);
      activeTimeline.to(parent.rotation, {
        y: Math.PI * 2,
        duration: 4,
        ease: 'none'
      }, 0);
    }

    // ITEM 5: Cube Matrix (3x3x3)
    function createItem5(parent) {
      const groupRef = new THREE.Group();
      parent.add(groupRef);

      const layer1 = new THREE.Group();
      const layer2 = new THREE.Group();
      const layer3 = new THREE.Group();

      const blockSize = 1;
      const gap = 0.1;
      const distance = blockSize + gap;

      for (let x = -1; x <= 1; x++) {
        for (let y = -1; y <= 1; y++) {
          for (let z = -1; z <= 1; z++) {
            const geometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
            const material = createMatcapMaterial();
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x * distance, y * distance, z * distance);

            if (z === -1) layer1.add(mesh);
            else if (z === 0) layer2.add(mesh);
            else layer3.add(mesh);
          }
        }
      }

      groupRef.add(layer1, layer2, layer3);
      groupRef.scale.setScalar(0.6);

      activeTimeline = gsap.timeline({ repeat: -1 });
      activeTimeline.to(layer1.rotation, { z: Math.PI, duration: 1.5 });
      activeTimeline.to(layer2.rotation, { z: Math.PI, duration: 1.5, delay: 0.15 }, '<');
      activeTimeline.to(layer3.rotation, { z: Math.PI, duration: 1.5, delay: 0.25 }, '<');
      activeTimeline.to(groupRef.rotation, { y: Math.PI * 2, duration: 1.75 }, 0);
    }

    // ITEM 6: Half Pipe Ball Roll
    function createItem6(parent) {
      const scale = 0.8;
      parent.scale.setScalar(scale);

      // Create semicircle curve
      class SemiCircleCurve extends THREE.Curve {
        constructor(scale = 1) {
          super();
          this.scale = scale;
        }
        getPoint(t) {
          const radians = t * Math.PI;
          const x = Math.cos(radians) * this.scale;
          const y = Math.sin(radians) * this.scale;
          return new THREE.Vector3(x, y, 0);
        }
      }

      const path = new SemiCircleCurve(2);
      const tubeMesh = new THREE.Mesh(
        new THREE.TubeGeometry(path, 20, 0.8, 8, false),
        createMatcapMaterial()
      );
      tubeMesh.material.side = THREE.DoubleSide;
      tubeMesh.rotation.z = Math.PI;
      parent.add(tubeMesh);

      const ball = new THREE.Mesh(
        new THREE.SphereGeometry(0.7),
        createMatcapMaterial()
      );
      ball.position.set(0, 2, 0);
      parent.add(ball);

      const t = { value: 0 };
      activeTimeline = gsap.timeline();
      activeTimeline.to(t, {
        value: 2,
        duration: 1.5,
        ease: 'none',
        repeat: -1,
        onUpdate: () => {
          const point = path.getPoint(t.value % 1);
          ball.position.copy(point);
        }
      });
      activeTimeline.to(tubeMesh.rotation, {
        z: -Math.PI,
        ease: 'back.out',
        duration: 1.5,
        repeat: -1
      }, 0);
    }

    // ITEM 7: Stack Flip
    function createItem7(parent) {
      const meshes = [];
      for (let i = 0; i < 5; i++) {
        const geometry = new THREE.BoxGeometry(1, 0.1, 1, 5, 5, 5);
        const material = createMatcapMaterial();
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.y = (i - 2) * 0.1;
        parent.add(mesh);
        meshes.push(mesh);
      }
      parent.scale.setScalar(3);
      parent.rotation.set(Math.PI / 10, Math.PI / 4, 0);

      activeTimeline = gsap.to(meshes.map(m => m.rotation), {
        y: `+=${Math.PI / 2}`,
        repeat: -1,
        ease: 'back',
        stagger: { each: 0.1 },
        duration: 1
      });
    }

    // ITEM 8: See Saw
    function createItem8(parent) {
      const bar = new THREE.Mesh(
        new THREE.BoxGeometry(4, 0.4, 1),
        createMatcapMaterial()
      );
      parent.add(bar);

      const cyl1 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5),
        createMatcapMaterial()
      );
      cyl1.position.set(1.5, 1, 0);
      cyl1.rotation.x = Math.PI / 2;
      parent.add(cyl1);

      const cyl2 = new THREE.Mesh(
        new THREE.CylinderGeometry(0.5, 0.5),
        createMatcapMaterial()
      );
      cyl2.position.set(-1.5, -1, 0);
      cyl2.rotation.x = Math.PI / 2;
      parent.add(cyl2);

      activeTimeline = gsap.timeline({ defaults: { ease: 'elastic', repeat: -1 } });
      activeTimeline.to(cyl1.position, {
        keyframes: [{ x: -1.5, duration: 2 }, { x: 1.5, duration: 2 }],
        repeat: -1
      });
      activeTimeline.to(cyl2.position, {
        keyframes: [{ x: 1.5, duration: 2 }, { x: -1.5, duration: 2 }],
        repeat: -1
      }, 0);
      activeTimeline.to(parent.rotation, {
        z: Math.PI,
        duration: 4
      }, 0);
    }

    // ITEM 9: Pulse Tower
    function createItem9(parent) {
      parent.rotation.set(0, 0, Math.PI / 4);
      const inner = new THREE.Group();
      inner.rotation.z = Math.PI / 2;
      parent.add(inner);

      const meshes = [];
      for (let i = 0; i < 10; i++) {
        const geometry = new THREE.CylinderGeometry(1, 1, 0.2, 64);
        const material = createMatcapMaterial();
        const mesh = new THREE.Mesh(geometry, material);
        mesh.position.set(0, 0.5 * i, 2);
        inner.add(mesh);
        meshes.push(mesh);

        gsap.to(mesh.scale, {
          x: 0.3,
          z: 0.3,
          delay: 0.25 * i,
          repeat: -1,
          yoyo: true,
          ease: 'sine.inOut',
          duration: 1
        });
      }
    }

    // ITEM 10: Quarter Circle
    function createItem10(parent) {
      parent.scale.setScalar(1.6);
      const groupRef = new THREE.Group();
      groupRef.rotation.x = Math.PI / 2;
      parent.add(groupRef);

      // Create extruded quarter circle shape
      const shape = new THREE.Shape();
      shape.absarc(0, 0, 1, 0, Math.PI / 2, false);
      shape.lineTo(Math.cos(Math.PI / 2) * 0.5, Math.sin(Math.PI / 2) * 0.5);
      shape.absarc(0, 0, 0.2, Math.PI / 2, 0, true);
      shape.lineTo(1, 0);

      const geometry = new THREE.ExtrudeGeometry(shape, {
        steps: 1,
        depth: 0.3,
        bevelEnabled: false
      });

      const holders = [];
      for (let i = 0; i < 4; i++) {
        const mesh = new THREE.Mesh(geometry, createMatcapMaterial());
        mesh.material.side = THREE.DoubleSide;
        mesh.rotation.x = Math.PI / 2;
        const holder = new THREE.Group();
        holder.rotation.y = (i * Math.PI) / 2;
        holder.add(mesh);
        groupRef.add(holder);
        holders.push(holder);
      }

      activeTimeline = gsap.timeline({ repeat: -1, repeatDelay: 0.5 });
      activeTimeline.to(holders.map(h => h.position), {
        x: (index) => `+=${Math.sin((index / 4) * 2 * Math.PI) * 0.5}`,
        z: (index) => `+=${Math.cos((index / 4) * 2 * Math.PI) * 0.5}`,
        duration: 1.5,
        ease: 'power1.out'
      });
      activeTimeline.to(holders.map(h => h.rotation), {
        z: `+=${Math.PI}`,
        duration: 2
      }, 0);
      activeTimeline.to(holders.map(h => h.position), {
        x: 0,
        z: 0,
        duration: 1.5
      }, 1);
    }

    // ITEM 11: Wave Spheres
    function createItem11(parent) {
      parent.scale.setScalar(0.55);

      const spheres = [];
      for (let i = 0; i < 5; i++) {
        const sphere = new THREE.Mesh(
          new THREE.SphereGeometry(1, 32, 32),
          createMatcapMaterial()
        );
        sphere.position.x = (i - 2) * 2;
        parent.add(sphere);
        spheres.push(sphere);
      }

      parent.userData.update = (time) => {
        const angle = Math.sin(time * 4);
        const angle1 = Math.min(0, angle * 0.5);
        const angle5 = Math.max(0, angle * 0.5);

        const positions = [
          { vector: new THREE.Vector3(-4, -4, 0), angle: angle1 },
          { vector: new THREE.Vector3(-2, -4, 0), angle: (angle + angle1) * 0.05 },
          { vector: new THREE.Vector3(0, -4, 0), angle: angle5 * 0.05 },
          { vector: new THREE.Vector3(2, -4, 0), angle: (angle + angle5) * 0.05 },
          { vector: new THREE.Vector3(4, -4, 0), angle: angle5 }
        ];

        positions.forEach(({ vector, angle }, i) => {
          const s = Math.sin(angle);
          const c = Math.cos(angle);
          const newX = vector.x * c - vector.y * s;
          const newY = vector.x * s + vector.y * c + 3;
          spheres[i].position.set(newX, newY, 0);
        });
      };
    }

    // ITEM 12: Arrow Spin
    function createItem12(parent) {
      parent.scale.setScalar(0.7);

      const cube = new THREE.Mesh(
        new THREE.BoxGeometry(),
        createMatcapMaterial()
      );
      parent.add(cube);

      // Create arrow shape
      const shape = new THREE.Shape();
      shape.moveTo(0, 0);
      shape.lineTo(1, 1);
      shape.lineTo(0.5, 1);
      shape.lineTo(0.5, 2);
      shape.lineTo(-0.5, 2);
      shape.lineTo(-0.5, 1);
      shape.lineTo(-1, 1);
      shape.lineTo(0, 0);

      const arrowGeometry = new THREE.ExtrudeGeometry(shape, {
        depth: 0.5,
        bevelEnabled: false
      });

      const arrows = [
        { position: [0, 2, -0.25], rotation: [0, 0, 0] },
        { position: [2, 0, -0.25], rotation: [0, 0, -Math.PI / 2] },
        { position: [0, -2, -0.25], rotation: [0, 0, -Math.PI] },
        { position: [-2, 0, -0.25], rotation: [0, 0, Math.PI / 2] }
      ];

      const arrowMeshes = [];
      arrows.forEach(a => {
        const mesh = new THREE.Mesh(arrowGeometry, createMatcapMaterial());
        mesh.position.set(...a.position);
        mesh.rotation.set(...a.rotation);
        parent.add(mesh);
        arrowMeshes.push(mesh);
      });

      activeTimeline = gsap.timeline();
      activeTimeline.from(arrowMeshes.map(m => m.rotation), {
        x: (index) => index === 1 ? Math.PI * 2 : index === 3 ? -Math.PI * 2 : 0,
        y: (index) => index === 0 ? Math.PI * 2 : index === 2 ? -Math.PI * 2 : 0,
        duration: 5,
        repeat: -1,
        ease: 'none'
      });
      activeTimeline.to(parent.rotation, {
        z: Math.PI * 2,
        duration: 10,
        repeat: -1,
        ease: 'none'
      }, 0);
    }

    // Animation update
    function updateAnimations(time) {
      if (currentGroup && currentGroup.userData.update) {
        currentGroup.userData.update(time);
      }
    }

    // Dispose of group
    function disposeGroup(group) {
      group.traverse((child) => {
        if (child.isMesh) {
          if (child.geometry) child.geometry.dispose();
          if (child.material) child.material.dispose();
        }
      });
    }

    // Setup event listeners
    function setupEventListeners() {
      itemButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          itemButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          createItem(parseInt(btn.dataset.item));
        });
      });

      matcapButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          matcapButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentMatcap = parseInt(btn.dataset.matcap);
          createItem(currentItem); // Recreate with new matcap
        });
      });

      window.addEventListener('resize', onWindowResize);
    }

    // Handle window resize
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Update FPS counter
    function updateFPS() {
      frameCount++;
      const now = performance.now();
      const delta = now - lastTime;

      if (delta >= 1000) {
        const fps = Math.round((frameCount * 1000) / delta);
        fpsSpan.textContent = fps;
        frameCount = 0;
        lastTime = now;
      }
    }

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);

      const time = performance.now() * 0.001;

      updateAnimations(time);
      controls.update();
      renderer.renderAsync(scene, camera);

      updateFPS();
    }

    // Start
    init();
  </script>
</body>
</html>
